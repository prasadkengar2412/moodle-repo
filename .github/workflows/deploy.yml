name: Moodle Plugin Workflow - develop

on:
  push:
    branches:
      - develop

  workflow_dispatch:
    inputs:
      branch:
        description: 'Select deployment branch'
        required: true
        type: choice
        default: 'develop'
        options:
          - 'develop'

env:
  MOODLE_ROOT: /var/www/html/moodle

jobs:
  detect-changes:
    name: Identify Changed Plugins
    runs-on: ubuntu-latest
    outputs:
      directories: ${{ steps.process-changes.outputs.dirs }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref_name }}
          fetch-depth: 0

      - name: Find Plugin Directories
        id: find-plugins
        run: |
          echo "Scanning for plugin directories containing version.php under plugins/"
          plugin_dirs=$(find plugins -type f -name version.php -exec dirname {} \; | sort -u)
          echo "Found plugin directories: $plugin_dirs"
          echo "plugin_dirs<<EOF" >> $GITHUB_OUTPUT
          echo "$plugin_dirs" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Process Changes
        id: process-changes
        run: |
          echo "Processing changes in the latest commit"
          changed_files=$(git diff --name-only HEAD^ HEAD)
          echo "Changed files detected: $changed_files"
          
          declare -A plugin_map
          
          echo "Checking plugin directories for changes"
          for dir in $(echo "${{ steps.find-plugins.outputs.plugin_dirs }}"); do
            if echo "$changed_files" | grep -q "^$dir/"; then
              echo "Change detected in directory: $dir"
              plugin_map["$dir"]=1
            fi
          done
          
          dir_list=$(printf "%s\n" "${!plugin_map[@]}" | sort -u)
          echo "List of directories with changes: $dir_list"
          
          if [[ -z "$dir_list" ]]; then
            json_dirs="[]"
            echo "No changes detected in plugin directories"
          else
            json_dirs=$(jq -nc '$ARGS.positional' --args ${dir_list})
            echo "Formatted changed directories as JSON: $json_dirs"
          fi
          
          echo "dirs=$json_dirs" >> $GITHUB_OUTPUT

  package-plugins:
    name: Package Changed Plugins
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.directories != '[]' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dir: ${{ fromJson(needs.detect-changes.outputs.directories) }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref_name }}

      - name: Create Plugin Bundle
        id: package
        run: |
          echo "Creating package for plugin: ${{ matrix.dir }}"
          safe_name=$(echo "${{ matrix.dir }}" | tr '/' '-')
          zip_file="${safe_name}-$(date +%Y%m%d-%H%M%S).zip"
          echo "Generated package name: $zip_file"
          
          cd "$(dirname "${{ matrix.dir }}")"
          echo "Zipping directory: $(basename "${{ matrix.dir }}")"
          zip -qr "$zip_file" "$(basename "${{ matrix.dir }}")"
          
          zip_path="$(pwd)/$zip_file"
          echo "Created package at: $zip_path"
          echo "zip=$zip_path" >> $GITHUB_OUTPUT
          echo "name=$safe_name" >> $GITHUB_OUTPUT
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: pkg-${{ steps.package.outputs.name }}
          path: ${{ steps.package.outputs.zip }}
          retention-days: 3

  deploy-plugins:
    name: Deploy to Server
    needs: [detect-changes, package-plugins]
    if: ${{ needs.detect-changes.outputs.directories != '[]' }}
    runs-on: ${{ 
                  github.event_name == 'workflow_dispatch' && github.event.inputs.branch == 'main' && fromJson('["self-hosted", "priavte2", "prod"]') ||
                  github.event_name == 'push' && github.ref_name == 'develop' && fromJson('["self-hosted", "private1", "dev"]')
              }}
    strategy:
      matrix:
        dir: ${{ fromJson(needs.detect-changes.outputs.directories) }}
    steps:
      - name: Compute Safe Name and Target Path
        id: compute-safe
        run: |
          echo "Computing safe name and target path for: ${{ matrix.dir }}"
          safe_name=$(echo "${{ matrix.dir }}" | tr '/' '-')
          deploy_subdir=$(echo "${{ matrix.dir }}" | sed 's|^plugins/||')
          case "${{ matrix.dir }}" in
            plugins/block/*) target_path="blocks/$(basename "${{ matrix.dir }}")" ;;
            plugins/customfield/*) target_path="customfield/field/$(basename "${{ matrix.dir }}")" ;;
            *) target_path="$deploy_subdir" ;;
          esac
          echo "Safe name: $safe_name"
          echo "Target path: $target_path"
          echo "safe_name=$safe_name" >> $GITHUB_OUTPUT
          echo "target_path=$target_path" >> $GITHUB_OUTPUT
      - name: Retrieve Package
        uses: actions/download-artifact@v4
        with:
          name: pkg-${{ steps.compute-safe.outputs.safe_name }}
          path: /tmp/deployment/${{ github.run_id }}

      - name: Enable Maintenance Mode
        run: |
          echo "Enabling maintenance mode"
          sudo -u www-data /usr/bin/php ${{ env.MOODLE_ROOT }}/admin/cli/maintenance.php --enable 
      - name: Backup Existing Plugin
        run: |
          set -eo pipefail
          trap 'echo "Backup failed at line $LINENO" && exit 1' ERR
          target_dir="${{ env.MOODLE_ROOT }}/${{ steps.compute-safe.outputs.target_path }}"
          backup_dir="/tmp/moodle-backups/${{ github.run_id }}/$(date +%Y%m%d)/${{ steps.compute-safe.outputs.target_path }}"
          echo "Checking if target directory exists: $target_dir"
          if [ -d "$target_dir" ]; then
            echo "Target directory exists, proceeding with backup"
            sudo mkdir -p "$backup_dir"
            echo "Created backup directory: $backup_dir"
            backup_file="$backup_dir/$(basename "$target_dir")-$(date +%H%M%S).tgz"
            echo "Creating backup file: $backup_file"
            sudo tar -czf "$backup_file" -C "$(dirname "$target_dir")" "$(basename "$target_dir")"
            echo "Backup completed successfully: $backup_file"
          else
            echo "No existing directory found at $target_dir, skipping backup"
          fi
      - name: Deploy Plugin
        run: |
          set -eo pipefail
          trap 'echo "Deployment failed at line $LINENO" && exit 1' ERR
          target_dir="${{ env.MOODLE_ROOT }}/${{ steps.compute-safe.outputs.target_path }}"
          safe_name="${{ steps.compute-safe.outputs.safe_name }}"
          echo "Deploying plugin to: $target_dir"
          zip_file=$(ls -t /tmp/deployment/${{ github.run_id }}/${safe_name}-*.zip | head -n 1)
          if [ -z "$zip_file" ]; then
            echo "Error: No ZIP file found for $safe_name"
            exit 1
          fi
          echo "Found ZIP file for deployment: $zip_file"
          echo "Ensuring parent directory exists: $(dirname "$target_dir")"
          sudo mkdir -p "$(dirname "$target_dir")"
          echo "Unzipping $zip_file to $(dirname "$target_dir")"
          sudo unzip -qo "$zip_file" -d "$(dirname "$target_dir")"
          echo "Setting ownership of $target_dir to www-data:www-data"
          sudo chown -R www-data:www-data "$target_dir"
          echo "Setting directory permissions to 777"
          sudo find "$target_dir" -type d -exec chmod 777 {} \;
          echo "Setting file permissions to 777"
          sudo find "$target_dir" -type f -exec chmod 777 {} \;
          echo "Deployment completed successfully for $target_dir"
      - name: Disable Maintenance Mode
        if: always() 
        run: |
          echo "Disabling maintenance mode"
          sudo -u www-data /usr/bin/php ${{ env.MOODLE_ROOT }}/admin/cli/maintenance.php --disable

  create-release:
    name: Create GitHub Release
    needs: [detect-changes, deploy-plugins]
    if: ${{ needs.detect-changes.outputs.directories != '[]' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref_name }}
          fetch-depth: 0
          
      - name: Get PR Description (if applicable)
        id: pr-description
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            pr_description=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}" \
              | jq -r '.body')
            echo "PR description fetched: $pr_description"
          else
            pr_description="No PR description available."
            echo "No PR description available."
          fi
          echo "pr_description=$pr_description" >> $GITHUB_OUTPUT
          
      - name: Generate Release Notes and Tags
        id: generate-release
        run: |
          echo "Generating release notes and tags for changed plugins"
          release_notes="${{ steps.pr-description.outputs.pr_description }}"
          tag_list=""
          for dir in $(echo '${{ needs.detect-changes.outputs.directories }}' | jq -r '.[]'); do
            echo "Processing directory: $dir"
            safe_name=$(echo "$dir" | tr '/' '-')
            plugin_name=$(basename "$dir")
            version_file="$dir/version.php"
            if [ -f "$version_file" ]; then
              echo "Extracting version from $version_file"
              version=$(grep -E '(\$plugin->version|\$module->version|\$version)\s*=' "$version_file" | \
                        sed -E 's/.*=\s*([0-9]+).*/\1/' | head -n 1)
              if [[ -z "$version" || ! "$version" =~ ^[0-9]+$ ]]; then
                version=$(date +%Y%m%d%H%M)
                echo "No valid numeric version found in $version_file, using timestamp: $version"
              else
                echo "Version found: $version"
              fi
            else
              version=$(date +%Y%m%d%H%M)
              echo "No version.php found, using timestamp: $version"
            fi
            tag="$safe_name-v$version"
            echo "Generated tag: $tag"
            tag_list="$tag_list $tag"
            # Fetch commit messages for files in the directory
            echo "Fetching commit messages for $dir"
            commit_messages=$(git log --pretty=format:"%s" HEAD^..HEAD -- "$dir" | sed 's/^/- /' | sort -u)
            if [[ -z "$commit_messages" ]]; then
              echo "No commit messages found for $dir"
              commit_messages="- No commit messages found for this plugin"
            else
              echo "Commit messages found for $dir:" 
              echo "$commit_messages"
            fi
            # Build release notes with plugin details and commit messages
            release_notes="$release_notes\n### $plugin_name\n- Version: $version\n- Directory: $dir\n#### Commits:\n$commit_messages\n"
          done
          echo "Final release notes:"
          echo -e "$release_notes"
          echo "tag_list=$tag_list"
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo -e "$release_notes" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "tags=$tag_list" >> $GITHUB_OUTPUT
          
      - name: Create Tags
        run: |
          echo "Creating tags"
          for tag in ${{ steps.generate-release.outputs.tags }}; do
            echo "Checking tag: $tag"
            if git rev-parse "$tag" >/dev/null 2>&1; then
              echo "Tag $tag already exists, generating unique tag"
              timestamp=$(date +%Y%m%d%H%M%S)
              new_tag="${tag}-${timestamp}"
              echo "Creating unique tag: $new_tag"
              git tag "$new_tag"
              git push origin "$new_tag"
            else
              echo "Creating tag: $tag"
              git tag "$tag"
              git push origin "$tag"
            fi
          done
          
      - name: Retrieve All Packages
        uses: actions/download-artifact@v4
        with:
          path: /tmp/release-artifacts/${{ github.run_id }}
          pattern: pkg-*
          merge-multiple: true

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
         echo "Creating GitHub release"
         # Get the first generated tag, or use the new tag if a duplicate was found
         first_tag=$(echo ${{ steps.generate-release.outputs.tags }} | cut -d' ' -f1)
         # Update to use the last generated unique tag if necessary
         new_tag=$(git tag -l "plugins-enrol-category-v*" | sort -r | head -n 1)
         echo "Using tag for release: $new_tag"
         release_name="Release $new_tag"
    
         # Create GitHub release using the new tag
         gh release create "$new_tag" \
         --title "$release_name" \
         --notes "${{ steps.generate-release.outputs.release_notes }}" \
         /tmp/release-artifacts/${{ github.run_id }}/*.zip
         echo "Release $release_name created successfully"